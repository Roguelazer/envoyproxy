use axum::{extract::State, response::IntoResponse};
use promformat::Metrics;
use serde::Serialize;

use std::sync::Arc;

use crate::state::{self, AppState, Inventory, SystemState};

#[derive(Serialize, Debug)]
struct ResponseBody {
    #[serde(flatten)]
    state: SystemState,
    #[serde(flatten)]
    inventory: Inventory,
    history: state::HistoryResponse,
}

#[derive(Serialize, Debug)]
struct HealthcheckResponse {
    is_ok: bool,
    message: String,
}

impl HealthcheckResponse {
    fn new<S: Into<String>>(is_ok: bool, s: S) -> Self {
        Self {
            is_ok,
            message: s.into(),
        }
    }
}

pub async fn healthcheck(State(state): State<Arc<AppState>>) -> impl IntoResponse {
    let state = state.system_state.read().await;
    if let Some(last_update) = state.last_update.as_ref() {
        (
            axum::http::StatusCode::OK,
            axum::Json(HealthcheckResponse::new(
                true,
                format!("data fetched as of {}", last_update),
            )),
        )
    } else {
        (
            axum::http::StatusCode::INTERNAL_SERVER_ERROR,
            axum::Json(HealthcheckResponse::new(false, "no data fetched")),
        )
    }
}

pub async fn metrics_json(
    State(state): State<Arc<AppState>>,
) -> axum::response::Json<impl Serialize> {
    let response_body = ResponseBody {
        state: state.system_state.read().await.clone(),
        inventory: state.inventory.read().await.clone(),
        history: state.history().await,
    };
    axum::Json(response_body)
}

pub async fn metrics_prom(State(raw_state): State<Arc<AppState>>) -> impl IntoResponse {
    let state = raw_state.system_state.read().await;
    let mut metrics = Metrics::new();
    if let Some(last_update) = state.last_update {
        for (mtype, source) in &[
            ("pv", state.pv_mw),
            ("grid", state.grid_mw),
            ("load", state.load_mw),
            ("storage", state.storage_mw),
        ] {
            let mut gauge = metrics.gauge(
                "power_milliwatts",
                "Power consumed or generated by this meter",
            );
            gauge
                .label("type", mtype)
                .set_with_timestamp(source, last_update);
        }
        let battery_gauge = metrics.gauge("battery_soc_percent", "Percent of battery available");
        battery_gauge.set_with_timestamp(state.battery_soc, last_update);
    }
    let inventory = raw_state.inventory.read().await;
    let battery_cap_gauge = metrics.gauge(
        "battery_capacity_wh",
        "Total battery capacity in watt-hours",
    );
    battery_cap_gauge.set(inventory.battery_capacity);
    let mut headers = axum::http::header::HeaderMap::new();
    headers.insert(
        axum::http::header::CONTENT_TYPE,
        axum::http::HeaderValue::from_static("text/plain; version=0.0.4"),
    );
    (
        axum::http::StatusCode::OK,
        headers,
        metrics.render().to_owned(),
    )
}

pub async fn root() -> impl IntoResponse {
    "hi"
}
